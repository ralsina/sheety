require "croupier"

module Sheety
  # Generates and registers Croupier tasks from Excel formulas
  class CroupierGenerator
    include AST

    # Structure to hold formula information
    struct FormulaInfo
      getter cell : String
      getter formula : String
      getter sheet : String?

      def initialize(@cell : String, @formula : String, @sheet : String? = nil)
      end

      def key : String
        @sheet ? "#{@sheet}!#{@cell}" : @cell
      end
    end

    @formulas : Hash(String, FormulaInfo)
    @generator : CodeGenerator
    @extractor : DependencyExtractor

    def initialize
      @formulas = Hash(String, FormulaInfo).new
      @generator = CodeGenerator.new
      @extractor = DependencyExtractor.new
    end

    # Add a formula to be converted to a task
    def add_formula(cell : String, formula : String, sheet : String? = nil) : self
      # Store formula as-is (we'll strip '=' when parsing)
      key = sheet ? "#{sheet}!#{cell}" : cell

      @formulas[key] = FormulaInfo.new(cell, formula, sheet)
      self
    end

    # Add multiple formulas from a hash
    def add_formulas(formulas : Hash(String, String), sheet : String? = nil) : self
      formulas.each do |cell, formula|
        add_formula(cell, formula, sheet)
      end
      self
    end

    # Parse formula string and validate it
    private def parse_formula(formula : String) : Node?
      _, builder = Parser.new.ast(formula)
      builder.root
    rescue e : FormulaError
      nil
    end

    # Generate and register all Croupier tasks
    def register_tasks : Nil
      @formulas.each do |_, info|
        register_single_task(info)
      end
    end

    # Generate and register a single task
    private def register_single_task(info : FormulaInfo) : Nil
      # Parse the formula
      formula = info.formula.starts_with?("=") ? info.formula : "=#{info.formula}"
      ast = parse_formula(formula)

      if ast.nil?
        # Invalid formula - create a task that returns an error
        create_error_task(info)
        return
      end

      # Extract dependencies
      dependencies = @extractor.extract(ast, info.sheet)

      # Generate the proc code
      proc_body = @generator.generate_proc_body(formula, CodeGenerator::Context.new(info.sheet))

      # Create the proc
      proc = ->{
        begin
          # Eval the generated code
          # Note: We need to use a different approach since Crystal doesn't have eval
          # For now, we'll return a placeholder
          "#VALUE!"
        rescue
          "#VALUE!"
        end
      }

      # Create and register the task
      task_id = "formula_#{sanitize_key(info.key)}"
      Croupier::Task.new(
        id: task_id,
        inputs: dependencies.to_a,
        outputs: [info.key],
        proc: proc
      )
    end

    # Sanitize key for use in task ID
    private def sanitize_key(key : String) : String
      key.gsub(/[!\/]/, "_")
    end

    # Create a task for an invalid formula
    private def create_error_task(info : FormulaInfo) : Nil
      proc = ->{ "#VALUE!" }
      task_id = "formula_#{sanitize_key(info.key)}"

      Croupier::Task.new(
        id: task_id,
        inputs: [] of String,
        outputs: [info.key],
        proc: proc
      )
    end

    # Generate Crystal source code for all tasks
    # This can be written to a file and compiled
    def generate_source : String
      source = %{
        require "croupier"
        require "./sheety/functions/registry"

        # Auto-generated Excel formula tasks for Croupier
        # Generated by Sheety

      }

      @formulas.each do |_, info|
        source += generate_single_task_source(info)
        source += "\n\n"
      end

      source
    end

    # Generate source code for a single task
    private def generate_single_task_source(info : FormulaInfo) : String
      formula = info.formula.starts_with?("=") ? info.formula : "=#{info.formula}"
      ast = parse_formula(formula)

      if ast.nil?
        # Invalid formula
        return %{
          # Error: Invalid formula for #{info.key}
          Croupier::Task.new(
            id: "formula_#{sanitize_key(info.key)}",
            inputs: [] of String,
            outputs: [#{info.key.inspect}],
          ) do
            "#VALUE!"
          end
        }
      end

      # Extract dependencies
      dependencies = @extractor.extract(ast, info.sheet)

      # Generate the calculation code
      calc_code = @generator.generate(ast, CodeGenerator::Context.new(info.sheet))

      # Build the task source
      %{
        # Formula: #{info.formula} at #{info.key}
        Croupier::Task.new(
          id: "formula_#{sanitize_key(info.key)}",
          inputs: [#{dependencies.map(&.inspect).join(", ")}],
          outputs: [#{info.key.inspect}],
        ) do
          result = (#{calc_code})

          # Convert result to string for storage
          case result
          when Float64
            if result == result.to_i
              result.to_i.to_s
            else
              result.to_s
            end
          when String
            result
          when Bool
            result.upcase.to_s
          when Sheety::Functions::ErrorValue
            result.to_s
          when Nil
            ""
          else
            result.to_s
          end
        end
      }
    end
  end
end
