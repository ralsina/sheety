require "croupier"
require "./ast"

module Sheety
  # Generates and registers Croupier tasks from Excel formulas
  class CroupierGenerator
    include AST

    # Structure to hold formula information
    struct FormulaInfo
      getter cell : String
      getter formula : String
      getter sheet : String?

      def initialize(@cell : String, @formula : String, @sheet : String? = nil)
      end

      def key : String
        @sheet ? "#{@sheet}!#{@cell}" : @cell
      end
    end

    @formulas : Hash(String, FormulaInfo)
    @generator : CodeGenerator
    @extractor : DependencyExtractor

    def initialize
      @formulas = Hash(String, FormulaInfo).new
      @generator = CodeGenerator.new
      @extractor = DependencyExtractor.new
    end

    # Add a formula to be converted to a task
    def add_formula(cell : String, formula : String, sheet : String? = nil) : self
      # Store formula as-is (we'll strip '=' when parsing)
      key = sheet ? "#{sheet}!#{cell}" : cell

      @formulas[key] = FormulaInfo.new(cell, formula, sheet)
      self
    end

    # Add multiple formulas from a hash
    def add_formulas(formulas : Hash(String, String), sheet : String? = nil) : self
      formulas.each do |cell, formula|
        add_formula(cell, formula, sheet)
      end
      self
    end

    # Parse formula string and validate it
    private def parse_formula(formula : String) : Node?
      _, builder = Parser.new.ast(formula)
      builder.root
    rescue e : FormulaError
      nil
    end

    # Generate and register all Croupier tasks
    def register_tasks : Nil
      @formulas.each do |_, info|
        register_single_task(info)
      end
    end

    # Generate and register a single task
    private def register_single_task(info : FormulaInfo) : Nil
      # Parse the formula
      formula = info.formula.starts_with?("=") ? info.formula : "=#{info.formula}"
      ast = parse_formula(formula)

      if ast.nil?
        # Invalid formula - create a task that returns an error
        create_error_task(info)
        return
      end

      # Extract dependencies
      dependencies = @extractor.extract(ast, info.sheet)

      # Generate the proc code
      proc_body = @generator.generate_proc_body(formula, CodeGenerator::Context.new(info.sheet))

      # Create the proc
      proc = ->{
        begin
          # Eval the generated code
          # Note: We need to use a different approach since Crystal doesn't have eval
          # For now, we'll return a placeholder
          "#VALUE!"
        rescue
          "#VALUE!"
        end
      }

      # Create and register the task
      task_id = "formula_#{sanitize_key(info.key)}"
      Croupier::Task.new(
        id: task_id,
        inputs: dependencies.to_a,
        outputs: [info.key],
        proc: proc
      )
    end

    # Sanitize key for use in task ID
    private def sanitize_key(key : String) : String
      key.gsub(/[!\/]/, "_")
    end

    # Create a task for an invalid formula
    private def create_error_task(info : FormulaInfo) : Nil
      proc = ->{ "#VALUE!" }
      task_id = "formula_#{sanitize_key(info.key)}"

      Croupier::Task.new(
        id: task_id,
        inputs: [] of String,
        outputs: [info.key],
        proc: proc
      )
    end

    # Generate Crystal source code for all tasks
    # This can be written to a file and compiled
    def generate_source(initial_values : Hash(String, Float64 | String | Bool) = Hash(String, Float64 | String | Bool).new) : String
      source = %{
        require "croupier"
        require "../src/sheety/functions/registry"

        # Auto-generated Excel formula tasks for Croupier
        # Generated by Sheety

      }

      # First add setup code (initial values)
      source += generate_setup_code(initial_values)
      source += "\n\n"

      # Then add formula calculations
      @formulas.each do |_, info|
        source += generate_single_task_source(info)
        source += "\n\n"
      end

      # Finally add print statements
      source += generate_print_code

      source
    end

    # Generate code to set initial values
    private def generate_setup_code(initial_values : Hash(String, Float64 | String | Bool)) : String
      value_assignments = initial_values.map do |key, value|
        value_str = case value
                    when Float64 then value.to_s.inspect  # Wrap in quotes
                    when String then value.inspect
                    when Bool then value.to_s
                    else "\"\""
                    end
        "Croupier::TaskManager.set(#{key.inspect}, #{value_str})"
      end.join("\n")

      setup = %{
# Set initial cell values
#{value_assignments}
}

      setup
    end

    # Generate code to print all results
    private def generate_print_code : String
      print_statements = @formulas.keys.sort.map do |key|
        "  puts \"#{key}: \" + (Croupier::TaskManager.get(#{key.inspect}) || \"(empty)\")"
      end.join("\n")

      %{
# Print all cell values
puts "=== Spreadsheet Results ==="
puts ""
#{print_statements}
puts ""
}
    end

    # Generate source code for a single task
    private def generate_single_task_source(info : FormulaInfo) : String
      formula = info.formula.starts_with?("=") ? info.formula : "=#{info.formula}"
      ast = parse_formula(formula)

      if ast.nil?
        # Invalid formula
        return %{
          # Error: Invalid formula for #{info.key}
          Croupier::Task.new(
            id: "formula_#{sanitize_key(info.key)}",
            inputs: [] of String,
            outputs: [#{info.key.inspect}],
          ) do
            "#VALUE!"
          end
        }
      end

      # Extract dependencies
      dependencies = @extractor.extract(ast, info.sheet)

      # Generate the calculation code
      calc_code = @generator.generate(ast, CodeGenerator::Context.new(info.sheet))

      # Build the task source with immediate execution
      %{
        # Formula: #{info.formula} at #{info.key}
        # Calculate and store result
        begin
          result = (#{calc_code})

          # Convert result to string for storage
          result_string = case result
          when Float64
            if result == result.to_i
              result.to_i.to_s
            else
              result.to_s
            end
          when String
            result
          when Bool
            result.upcase.to_s
          when Sheety::Functions::ErrorValue
            result.to_s
          when Nil
            ""
          else
            result.to_s
          end

          Croupier::TaskManager.set(#{info.key.inspect}, result_string)
        rescue e : Exception
          Croupier::TaskManager.set(#{info.key.inspect}, "#ERROR: " + (e.message || "Unknown error"))
        end
      }
    end
  end
end
