require "croupier"
require "./ast"

module Sheety
  # Generates and registers Croupier tasks from Excel formulas
  class CroupierGenerator
    include AST

    # Structure to hold formula information
    struct FormulaInfo
      getter cell : String
      getter formula : String
      getter sheet : String?

      def initialize(@cell : String, @formula : String, @sheet : String? = nil)
      end

      def key : String
        @sheet ? "#{@sheet}!#{@cell}" : @cell
      end
    end

    @formulas : Hash(String, FormulaInfo)
    @generator : CodeGenerator
    @extractor : DependencyExtractor

    def initialize
      @formulas = Hash(String, FormulaInfo).new
      @generator = CodeGenerator.new
      @extractor = DependencyExtractor.new
    end

    # Add a formula to be converted to a task
    def add_formula(cell : String, formula : String, sheet : String? = nil) : self
      # Store formula as-is (we'll strip '=' when parsing)
      key = sheet ? "#{sheet}!#{cell}" : cell

      @formulas[key] = FormulaInfo.new(cell, formula, sheet)
      self
    end

    # Add multiple formulas from a hash
    def add_formulas(formulas : Hash(String, String), sheet : String? = nil) : self
      formulas.each do |cell, formula|
        add_formula(cell, formula, sheet)
      end
      self
    end

    # Parse formula string and validate it
    private def parse_formula(formula : String) : Node?
      _, builder = Parser.new.ast(formula)
      builder.root
    rescue e : FormulaError
      nil
    end

    # Generate and register all Croupier tasks
    def register_tasks : Nil
      @formulas.each do |_, info|
        register_single_task(info)
      end
    end

    # Generate and register a single task
    private def register_single_task(info : FormulaInfo) : Nil
      # Parse the formula
      formula = info.formula.starts_with?("=") ? info.formula : "=#{info.formula}"
      ast = parse_formula(formula)

      if ast.nil?
        # Invalid formula - create a task that returns an error
        create_error_task(info)
        return
      end

      # Extract dependencies
      dependencies = @extractor.extract(ast, info.sheet)

      # Generate the proc code
      proc_body = @generator.generate_proc_body(formula, CodeGenerator::Context.new(info.sheet))

      # Create the proc
      proc = ->{
        begin
          # Eval the generated code
          # Note: We need to use a different approach since Crystal doesn't have eval
          # For now, we'll return a placeholder
          "#VALUE!"
        rescue
          "#VALUE!"
        end
      }

      # Create and register the task
      task_id = "formula_#{sanitize_key(info.key)}"
      Croupier::Task.new(
        id: task_id,
        inputs: dependencies.to_a,
        outputs: [info.key],
        proc: proc
      )
    end

    # Sanitize key for use in task ID
    private def sanitize_key(key : String) : String
      key.gsub(/[!\/]/, "_")
    end

    # Create a task for an invalid formula
    private def create_error_task(info : FormulaInfo) : Nil
      proc = ->{ "#VALUE!" }
      task_id = "formula_#{sanitize_key(info.key)}"

      Croupier::Task.new(
        id: task_id,
        inputs: [] of String,
        outputs: [info.key],
        proc: proc
      )
    end

    # Generate Crystal source code for all tasks
    # This can be written to a file and compiled
    def generate_source(initial_values : Hash(String, Float64 | String | Bool) = Hash(String, Float64 | String | Bool).new) : String
      source = %{
        require "croupier"
        require "tablo"
        require "../src/sheety/functions/registry"

        # Auto-generated Excel formula tasks for Croupier
        # Generated by Sheety

      }

      # First add setup code (initial values)
      source += generate_setup_code(initial_values)
      source += "\n\n"

      # Then add task definitions
      @formulas.each do |_, info|
        source += generate_single_task_source(info)
        source += "\n\n"
      end

      # Finally, run the tasks and print results as a table
      source += generate_execution_code

      source
    end

    # Generate code to set initial values
    private def generate_setup_code(initial_values : Hash(String, Float64 | String | Bool)) : String
      value_assignments = initial_values.map do |key, value|
        value_str = case value
                    when Float64 then value.to_s.inspect  # Wrap in quotes
                    when String then value.inspect
                    when Bool then value.to_s
                    else "\"\""
                    end
        "Croupier::TaskManager.set(#{key.inspect}, #{value_str})"
      end.join("\n")

      setup = %{
# Set initial cell values
#{value_assignments}
}

      setup
    end

    # Generate code to execute tasks and print results
    private def generate_execution_code : String
      # Get all unique cells (both initial values and formulas)
      all_cells = (@formulas.keys.to_a).sort

      # Generate table data directly
      rows = all_cells.map do |key|
        sheet, cell = key.split("!", 2)
        info = @formulas[key]
        formula = info ? info.formula : ""
        "  {sheet: #{sheet.inspect}, cell: #{cell.inspect}, formula: #{formula.inspect}, value: Croupier::TaskManager.get(#{key.inspect}) || \"(empty)\"}"
      end.join(",\n")

      # Generate code to display results in a table
      %{
# Execute all tasks
puts "=== Executing Croupier Tasks ==="
Croupier::TaskManager.run_tasks

# Display results in a table
puts ""
puts "=== Spreadsheet Results ==="
puts ""

# Create table data
table_data = [
#{rows}
]

# Create and print table
table = Tablo::Table.new(table_data) do |t|
  t.add_column(:sheet, header: "Sheet") { |d| d[:sheet] }
  t.add_column(:cell, header: "Cell") { |d| d[:cell] }
  t.add_column(:formula, header: "Formula") { |d| d[:formula] }
  t.add_column(:value, header: "Value") { |d| d[:value] }
end

puts table
puts ""
}
    end

    # Generate source code for a single task
    private def generate_single_task_source(info : FormulaInfo) : String
      formula = info.formula.starts_with?("=") ? info.formula : "=#{info.formula}"
      ast = parse_formula(formula)

      if ast.nil?
        # Invalid formula
        return %{
          Croupier::Task.new(
            id: "formula_#{sanitize_key(info.key)}",
            inputs: [] of String,
            outputs: [#{info.key.inspect}],
          ) do
            "#VALUE!"
          end
        }
      end

      # Extract dependencies - these are the inputs
      # Add kv:// prefix for k/v store keys
      dependencies = @extractor.extract(ast, info.sheet).map { |d| "kv://#{d}" }.to_a

      # Generate the calculation code
      calc_code = @generator.generate(ast, CodeGenerator::Context.new(info.sheet))

      # Build the task - the proc should return the result as a string
      %{
        Croupier::Task.new(
          id: "formula_#{sanitize_key(info.key)}",
          inputs: [#{dependencies.map(&.inspect).join(", ")}],
          outputs: ["kv://#{info.key}"],
        ) do
          begin
            result = (#{calc_code})

            # Convert result to string - this is what the task "outputs"
            case result
            when Float64
              if result == result.to_i
                result.to_i.to_s
              else
                result.to_s
              end
            when String
              result
            when Bool
              result.upcase.to_s
            when Sheety::Functions::ErrorValue
              result.to_s
            when Nil
              ""
            else
              result.to_s
            end
          rescue e : Exception
            "#ERROR: " + (e.message || "Unknown error")
          end
        end
      }
    end
  end
end
