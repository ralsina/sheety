require "big"
require "croupier"
require "./ast"

module Sheety
  # Generates and registers Croupier tasks from Excel formulas
  class CroupierGenerator
    include AST

    # Structure to hold formula information
    struct FormulaInfo
      getter cell : String
      getter formula : String
      getter sheet : String?

      def initialize(@cell : String, @formula : String, @sheet : String? = nil)
      end

      def key : String
        @sheet ? "#{@sheet}!#{@cell}" : @cell
      end
    end

    @formulas : Hash(String, FormulaInfo)
    @generator : CodeGenerator
    @extractor : DependencyExtractor
    @state_file_path : String?
    @kv_store_path : String?
    @spreadsheet_uuid : String?
    @original_filename : String?

    def initialize
      @formulas = Hash(String, FormulaInfo).new
      @generator = CodeGenerator.new
      @extractor = DependencyExtractor.new
      @state_file_path = nil
      @kv_store_path = nil
      @spreadsheet_uuid = nil
      @original_filename = nil
    end

    # Set the original filename (for save functionality)
    def set_original_filename(filename : String) : self
      @original_filename = filename
      self
    end

    # Set the path for the .croupier state file
    def set_state_file_path(path : String) : self
      @state_file_path = path
      self
    end

    # Set the path for the persistent k/v store
    def set_kv_store_path(path : String) : self
      @kv_store_path = path
      self
    end

    # Set the spreadsheet UUID (for tracking purposes)
    def set_spreadsheet_uuid(uuid : String) : self
      @spreadsheet_uuid = uuid
      self
    end

    # Add a formula to be converted to a task
    def add_formula(cell : String, formula : String, sheet : String? = nil) : self
      # Store formula as-is (we'll strip '=' when parsing)
      key = sheet ? "#{sheet}!#{cell}" : cell

      @formulas[key] = FormulaInfo.new(cell, formula, sheet)
      self
    end

    # Parse formula string and validate it
    private def parse_formula(formula : String) : Node?
      _, builder = Parser.new.ast(formula)
      builder.root
    rescue e : FormulaError
      nil
    end

    # Sanitize key for use in task ID
    private def sanitize_key(key : String) : String
      key.gsub(/[!\/]/, "_")
    end

    # Generate Crystal source code for all tasks
    # This can be written to a file and compiled
    def generate_source(initial_values : Hash(String, BigFloat | String | Bool) = Hash(String, BigFloat | String | Bool).new, interactive : Bool = false, source_file : String? = nil, intermediate_file : String? = nil) : String
      if interactive
        # For interactive mode, require termisu instead of tablo
        source = %{
          require "croupier"
          require "termisu"
          require "../src/sheety/tui"
          require "../src/sheety/functions/registry"
          require "../src/sheety/croupier_helpers"

          # Auto-generated Excel formula tasks for Croupier
          # Generated by Sheety

        }
      else
        source = %{
          require "croupier"
          require "tablo"
          require "../src/sheety/functions/registry"
          require "../src/sheety/croupier_helpers"

          # Auto-generated Excel formula tasks for Croupier
          # Generated by Sheety

        }
      end

      # First add setup code (initial values)
      source += generate_setup_code(initial_values)
      source += "\n\n"

      # Ensure directories exist for state files
      if @state_file_path || @kv_store_path
        source += "# Ensure parent directories exist for state files\n"
        if @state_file_path
          source += "state_dir = File.dirname(#{@state_file_path.inspect})\n"
          source += "Dir.mkdir_p(state_dir) unless Dir.exists?(state_dir)\n"
        end
        if @kv_store_path
          source += "Dir.mkdir_p(#{@kv_store_path.inspect}) unless Dir.exists?(#{@kv_store_path.inspect})\n"
        end
        source += "\n"
      end

      # Configure state file path if set
      if @state_file_path
        source += "# Configure Croupier state file path\n"
        source += "Croupier::TaskManager.state_file = #{@state_file_path.inspect}\n\n"
      end

      # Configure persistent k/v store if set
      if @kv_store_path
        source += "# Configure persistent k/v store for caching results across runs\n"
        source += "Croupier::TaskManager.use_persistent_store(#{@kv_store_path.inspect})\n\n"
      end

      source += "\n"

      # Then add task definitions
      @formulas.each do |_, info|
        source += generate_single_task_source(info)
        source += "\n\n"
      end

      # Finally, run the tasks and print results
      if interactive
        source += generate_tui_mode(initial_values, source_file, intermediate_file)
      else
        source += generate_execution_code(initial_values)
      end

      source
    end

    # Generate code to set initial values
    private def generate_setup_code(initial_values : Hash(String, BigFloat | String | Bool)) : String
      # Collect all unique ranges from formulas
      ranges = Set(NamedTuple(sheet: String, start_col: String, start_row: Int32, end_col: String, end_row: Int32)).new

      @formulas.each do |_, info|
        formula = info.formula.starts_with?("=") ? info.formula : "=#{info.formula}"
        ast = parse_formula(formula)
        next if ast.nil?

        # Extract dependencies including expanded ranges
        dependencies = @extractor.extract(ast, info.sheet)
        dependencies.each do |dep|
          # Check if this dependency is a range reference by looking for patterns
          # We need to find the original range references in the AST
        end

        # Find range references directly in the calc code
        calc_code = @generator.generate(ast, CodeGenerator::Context.new(info.sheet))
        if calc_code.includes?("fetch_cell_range(")
          # Extract all range parameters (not just the first one)
          calc_code.scan(/fetch_cell_range\("([^"]+)", "([A-Z]+)", (\d+), "([A-Z]+)", (\d+)\)/) do |match|
            ranges << {
              sheet: match[1],
              start_col: match[2],
              start_row: match[3].to_i,
              end_col: match[4],
              end_row: match[5].to_i
            }
          end
        end
      end

      # Build a hash of only the cells with actual values
      all_cells = Hash(String, String).new

      # Add user-provided values
      initial_values.each do |key, value|
        value_str = case value
                    when BigFloat then value.to_s
                    when String  then value
                    when Bool    then value.to_s
                    else              ""
                    end
        all_cells[key] = value_str
      end

      # Build setup code
      setup = ""

      # First, initialize all ranges to empty strings (required by Croupier)
      ranges.each do |range|
        setup += %{
initialize_range(#{range[:sheet].inspect}, #{range[:start_col].inspect}, #{range[:start_row]}, #{range[:end_col].inspect}, #{range[:end_row]})
}
      end

      # Then, set the cells with actual values
      unless all_cells.empty?
        setup += %{
# Set initial cell values
initialize_cells(#{all_cells.inspect})

}
      end

      setup
    end

    # Generate code to execute tasks and print results
    private def generate_execution_code(initial_values : Hash(String, BigFloat | String | Bool)) : String
      # Group cells by sheet and organize in grid
      sheets_data = {} of String => Hash(String, Hash(String, String))

      # Add formula cells
      @formulas.each do |key, info|
        parts = key.split("!", 2)
        sheet = parts.size > 1 ? parts[0] : "" # Use empty string for default sheet
        cell = parts.size > 1 ? parts[1] : parts[0]

        sheets_data[sheet] ||= Hash(String, Hash(String, String)).new
        sheets_data[sheet][cell] = {"formula" => info.formula}
      end

      # Add initial value cells (that don't have formulas)
      initial_values.each do |key, _|
        parts = key.split("!", 2)
        sheet = parts.size > 1 ? parts[0] : ""
        cell = parts.size > 1 ? parts[1] : parts[0]

        sheets_data[sheet] ||= Hash(String, Hash(String, String)).new
        # Only add if there's no formula already
        unless sheets_data[sheet][cell]?
          sheets_data[sheet][cell] = {"formula" => ""}
        end
      end

      # Generate code to collect all cell data per sheet
      sheet_collection_code = sheets_data.map do |sheet, cells|
        sheet_display_name = sheet.empty? ? "(default)" : sheet
        sheet_var_name = sheet.empty? ? "default" : sheet.gsub(/[^a-zA-Z0-9]/, "_")
        sheet_key_prefix = sheet.empty? ? "" : "#{sheet}!"

        cells_array = cells.map do |cell, data|
          "{cell: #{cell.inspect}, formula: #{data["formula"].inspect}, value: Croupier::TaskManager.get(\"#{sheet_key_prefix}#{cell}\") || \"(empty)\"}"
        end.join(",\n          ")

        "  # Sheet: #{sheet_display_name}
  sheet_#{sheet_var_name}_data = [
            #{cells_array}
          ]"
      end.join("\n\n")

      sheet_print_code = sheets_data.keys.sort!.map do |sheet|
        sheet_var_name = sheet.empty? ? "default" : sheet.gsub(/[^a-zA-Z0-9]/, "_")
        sheet_display_name = sheet.empty? ? "(default)" : sheet
        "  print_sheet(sheet_#{sheet_var_name}_data, #{sheet_display_name.inspect})"
      end.join("\n")

      # Generate code to display results in a sheet layout
      %{
# Execute all tasks
puts "=== Executing Croupier Tasks ==="
Croupier::TaskManager.run_tasks

# Display results as sheets
puts ""
puts "=== Spreadsheet Results ==="
puts ""

#{sheet_collection_code}

# Helper function to convert column number to letters
def col_num_to_letter(num)
  result = ""
  while num > 0
    num -= 1
    result = ('A' + (num % 26)).to_s + result
    num //= 26
  end
  result
end

def print_sheet(data, sheet_name)
  # Find the grid dimensions
  max_col = 0
  max_row = 0

  data.each do |cell|
    if match = cell[:cell].match(/^([A-Z]+)(\\d+)$/)
      col = match[1]
      row = match[2].to_i

      # Convert column to number for comparison
      col_num = 0
      col.each_char { |c| col_num = col_num * 26 + (c.ord - 'A'.ord + 1) }

      max_col = col_num if col_num > max_col
      max_row = row if row > max_row
    end
  end

  # Create a 2D grid
  grid = Array.new(max_row) { Array.new(max_col, "") }

  # Fill the grid
  data.each do |cell|
    if match = cell[:cell].match(/^([A-Z]+)(\\d+)$/)
      col = match[1]
      row = match[2].to_i - 1  # Convert to 0-indexed

      # Convert column to number
      col_num = 0
      col.each_char { |c| col_num = col_num * 26 + (c.ord - 'A'.ord + 1) }

      value = cell[:value]
      formula = cell[:formula]

      # Display: if there's a formula, show it, otherwise just the value
      display = formula.empty? ? value : formula + " -> " + value

      grid[row][col_num - 1] = display
    end
  end

  # Build column headers (A, B, C, ...)
  column_headers = (1..max_col).map { |i| col_num_to_letter(i) }

  # Build table data with row numbers
  table_data = (0...max_row).map do |row_idx|
    [row_idx + 1] + grid[row_idx]
  end

  # Create and print the table using Tablo
  table = Tablo::Table.new(table_data) do |t|
    t.add_column("Row", &.[](0).to_s)
    (1..max_col).each do |col_idx|
      t.add_column(column_headers[col_idx - 1], &.[](col_idx).to_s)
    end
  end

  puts table
  puts ""
end

#{sheet_print_code}
puts ""
}
    end

    # Generate source code for a single task
    private def generate_single_task_source(info : FormulaInfo) : String
      formula = info.formula.starts_with?("=") ? info.formula : "=#{info.formula}"
      ast = parse_formula(formula)

      if ast.nil?
        # Invalid formula
        return %{
          Croupier::Task.new(
            id: "formula_#{sanitize_key(info.key)}",
            inputs: [] of String,
            outputs: [#{info.key.inspect}],
          ) do
            "#VALUE!"
          end
        }
      end

      # Extract dependencies - these are the inputs
      dependencies = @extractor.extract(ast, info.sheet)

      # Generate the calculation code
      calc_code = @generator.generate(ast, CodeGenerator::Context.new(info.sheet))

      # Build the inputs array - use helpers if the formula uses ranges
      # Find all fetch_cell_range calls
      range_matches = calc_code.scan(/fetch_cell_range\(([^)]+)\)/).map(&.[1])

      inputs_code = if !range_matches.empty?
                      # Multiple ranges - combine them with + operator
                      range_inputs_calls = range_matches.map { |range_params| "range_inputs(#{range_params})" }
                      range_inputs_calls.join(" + ")
                    elsif dependencies.empty?
                      "[] of String"
                    else
                      "[" + dependencies.map { |dep| "\"kv://#{dep}\"" }.join(", ") + "] of String"
                    end

      # Build the task - the proc should return the result as a string
      %{
        Croupier::Task.new(
          id: "formula_#{sanitize_key(info.key)}",
          inputs: #{inputs_code},
          outputs: ["kv://#{info.key}"],
        ) do
          begin
            result = (#{calc_code})
            format_result(result)
          rescue e : Exception
            "#ERROR: " + (e.message || "Unknown error")
          end
        end
      }
    end

    # Generate TUI mode
    private def generate_tui_mode(initial_values : Hash(String, BigFloat | String | Bool), source_file : String?, intermediate_file : String?) : String
      # Get the sheet data collection code
      sheets_data = {} of String => Hash(String, Hash(String, String))

      @formulas.each do |key, info|
        parts = key.split("!", 2)
        sheet = parts.size > 1 ? parts[0] : ""
        cell = parts.size > 1 ? parts[1] : parts[0]

        sheets_data[sheet] ||= Hash(String, Hash(String, String)).new
        sheets_data[sheet][cell] = {"formula" => info.formula}
      end

      initial_values.each do |key, _|
        parts = key.split("!", 2)
        sheet = parts.size > 1 ? parts[0] : ""
        cell = parts.size > 1 ? parts[1] : parts[0]

        sheets_data[sheet] ||= Hash(String, Hash(String, String)).new
        unless sheets_data[sheet][cell]?
          sheets_data[sheet][cell] = {"formula" => ""}
        end
      end

      # Generate code to collect all cell data per sheet
      sheet_collection_code = sheets_data.map do |sheet, cells|
        sheet_var_name = sheet.empty? ? "default" : sheet.gsub(/[^a-zA-Z0-9]/, "_")
        sheet_key_prefix = sheet.empty? ? "" : "#{sheet}!"

        cells_array = cells.map do |cell, data|
          "{cell: #{cell.inspect}, formula: #{data["formula"].inspect}, value: fetch_cell(\"#{sheet_key_prefix}#{cell}\")}"
        end.join(",\n          ")

        "  sheet_#{sheet_var_name}_data = [
            #{cells_array}
          ]"
      end.join("\n\n")

      # Build the sheets array and data hash
      sheets_array = sheets_data.keys.sort!.map do |sheet|
        sheet.inspect
      end.join(", ")

      sheets_data_init = sheets_data.keys.sort!.map do |sheet|
        sheet_var_name = sheet.empty? ? "default" : sheet.gsub(/[^a-zA-Z0-9]/, "_")
        "#{sheet.inspect} => sheet_#{sheet_var_name}_data"
      end.join(",\n    ")

      %{
# Execute all tasks
puts "=== Executing Croupier Tasks ==="
Croupier::TaskManager.run_tasks

# Collect cell data for TUI
#{sheet_collection_code}

# Build sheets array and data hash
sheets = [#{sheets_array}]
sheet_data = {
    #{sheets_data_init}
  }

# Create TUI instance
tui = Sheety::TUI.new(sheets, sheet_data) do |sheet, cell_ref, new_value|
  # Update callback: called when user saves a cell edit
  full_key = sheet.empty? ? cell_ref : sheet + "!" + cell_ref

  # Update the value in Croupier store
  Croupier::TaskManager.set(full_key, new_value)

  # Re-run dependent tasks
  Croupier::TaskManager.run_tasks
end

# Set source file for save functionality
#{source_file ? "tui.set_source_file(#{source_file.inspect})" : ""}

# Set original source file for saves (persists across rebuilds)
#{@original_filename ? "tui.set_original_source_file(#{@original_filename.inspect})" : (source_file ? "tui.set_original_source_file(#{source_file.inspect})" : "")}

# Set intermediate file for auto-saves (formula edits)
#{intermediate_file ? "tui.set_intermediate_file(#{intermediate_file.inspect})" : ""}

# Set value getter callback to fetch fresh values from Croupier store
tui.set_value_getter do |sheet, cell_ref|
  fetch_cell(sheet.empty? ? cell_ref : sheet + "!" + cell_ref)
end

# Set refresh callback to refresh the grid after updates
tui.set_refresh_callback do
  tui.refresh_current_sheet
end

# Restore UI state if available
#{source_file ? %{
# Try to restore cursor position from YAML
begin
  yaml_data = YAML.parse(File.read(#{source_file.inspect}))
  if yaml_data.as_h.has_key?("_ui_state")
    ui_state = yaml_data["_ui_state"]
    if ui_state.as_h.has_key?("active_sheet") && ui_state.as_h.has_key?("active_cell")
      saved_sheet = ui_state["active_sheet"].as_s
      saved_cell = ui_state["active_cell"].as_s
      tui.set_initial_position(saved_sheet, saved_cell)
    end
  end
rescue
  # Ignore errors restoring UI state
end
} : ""}

# Run the TUI
tui.run
}
    end
  end
end
