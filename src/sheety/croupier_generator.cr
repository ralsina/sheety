require "croupier"
require "./ast"

module Sheety
  # Generates and registers Croupier tasks from Excel formulas
  class CroupierGenerator
    include AST

    # Structure to hold formula information
    struct FormulaInfo
      getter cell : String
      getter formula : String
      getter sheet : String?

      def initialize(@cell : String, @formula : String, @sheet : String? = nil)
      end

      def key : String
        @sheet ? "#{@sheet}!#{@cell}" : @cell
      end
    end

    @formulas : Hash(String, FormulaInfo)
    @generator : CodeGenerator
    @extractor : DependencyExtractor

    def initialize
      @formulas = Hash(String, FormulaInfo).new
      @generator = CodeGenerator.new
      @extractor = DependencyExtractor.new
    end

    # Add a formula to be converted to a task
    def add_formula(cell : String, formula : String, sheet : String? = nil) : self
      # Store formula as-is (we'll strip '=' when parsing)
      key = sheet ? "#{sheet}!#{cell}" : cell

      @formulas[key] = FormulaInfo.new(cell, formula, sheet)
      self
    end

    # Add multiple formulas from a hash
    def add_formulas(formulas : Hash(String, String), sheet : String? = nil) : self
      formulas.each do |cell, formula|
        add_formula(cell, formula, sheet)
      end
      self
    end

    # Parse formula string and validate it
    private def parse_formula(formula : String) : Node?
      _, builder = Parser.new.ast(formula)
      builder.root
    rescue e : FormulaError
      nil
    end

    # Generate and register all Croupier tasks
    def register_tasks : Nil
      @formulas.each do |_, info|
        register_single_task(info)
      end
    end

    # Generate and register a single task
    private def register_single_task(info : FormulaInfo) : Nil
      # Parse the formula
      formula = info.formula.starts_with?("=") ? info.formula : "=#{info.formula}"
      ast = parse_formula(formula)

      if ast.nil?
        # Invalid formula - create a task that returns an error
        create_error_task(info)
        return
      end

      # Extract dependencies
      dependencies = @extractor.extract(ast, info.sheet)

      # Create the proc
      proc = -> {
        begin
          # Eval the generated code
          # Note: We need to use a different approach since Crystal doesn't have eval
          # For now, we'll return a placeholder
          "#VALUE!"
        rescue
          "#VALUE!"
        end
      }

      # Create and register the task
      task_id = "formula_#{sanitize_key(info.key)}"
      Croupier::Task.new(
        id: task_id,
        inputs: dependencies.to_a,
        outputs: [info.key],
        proc: proc
      )
    end

    # Sanitize key for use in task ID
    private def sanitize_key(key : String) : String
      key.gsub(/[!\/]/, "_")
    end

    # Create a task for an invalid formula
    private def create_error_task(info : FormulaInfo) : Nil
      proc = -> { "#VALUE!" }
      task_id = "formula_#{sanitize_key(info.key)}"

      Croupier::Task.new(
        id: task_id,
        inputs: [] of String,
        outputs: [info.key],
        proc: proc
      )
    end

    # Generate Crystal source code for all tasks
    # This can be written to a file and compiled
    def generate_source(initial_values : Hash(String, Float64 | String | Bool) = Hash(String, Float64 | String | Bool).new, interactive : Bool = false) : String
      if interactive
        # For interactive mode, require termisu instead of tablo
        source = %{
          require "croupier"
          require "termisu"
          require "../src/sheety/tui"
          require "../src/sheety/functions/registry"

          # Auto-generated Excel formula tasks for Croupier
          # Generated by Sheety

        }
      else
        source = %{
          require "croupier"
          require "tablo"
          require "../src/sheety/functions/registry"

          # Auto-generated Excel formula tasks for Croupier
          # Generated by Sheety

        }
      end

      # First add setup code (initial values)
      source += generate_setup_code(initial_values)
      source += "\n\n"

      # Then add task definitions
      @formulas.each do |_, info|
        source += generate_single_task_source(info)
        source += "\n\n"
      end

      # Finally, run the tasks and print results
      if interactive
        source += generate_tui_mode(initial_values)
      else
        source += generate_execution_code(initial_values)
      end

      source
    end

    # Generate code to set initial values
    private def generate_setup_code(initial_values : Hash(String, Float64 | String | Bool)) : String
      # Collect ALL cell references from formulas to ensure dependencies exist
      all_referenced_cells = Set(String).new

      @formulas.each do |_, info|
        formula = info.formula.starts_with?("=") ? info.formula : "=#{info.formula}"
        ast = parse_formula(formula)
        next if ast.nil?

        # Extract dependencies including expanded ranges
        dependencies = @extractor.extract(ast, info.sheet)
        dependencies.each { |dep| all_referenced_cells << dep }
      end

      # Generate assignments for initial values
      value_assignments = [] of String

      # First, set user-provided values
      initial_values.each do |key, value|
        value_str = case value
                    when Float64 then value.to_s.inspect
                    when String  then value.inspect
                    when Bool    then value.to_s
                    else              "\"\""
                    end
        value_assignments << "Croupier::TaskManager.set(#{key.inspect}, #{value_str})"
      end

      # Then, initialize any missing referenced cells with empty string
      all_referenced_cells.each do |cell_ref|
        unless initial_values.has_key?(cell_ref)
          value_assignments << "Croupier::TaskManager.set(#{cell_ref.inspect}, \"\")"
        end
      end

      setup = %{
# Set initial cell values
#{value_assignments.join("\n")}
}

      setup
    end

    # Generate code to execute tasks and print results
    private def generate_execution_code(initial_values : Hash(String, Float64 | String | Bool)) : String
      # Group cells by sheet and organize in grid
      sheets_data = {} of String => Hash(String, Hash(String, String))

      # Add formula cells
      @formulas.each do |key, info|
        parts = key.split("!", 2)
        sheet = parts.size > 1 ? parts[0] : "" # Use empty string for default sheet
        cell = parts.size > 1 ? parts[1] : parts[0]

        sheets_data[sheet] ||= Hash(String, Hash(String, String)).new
        sheets_data[sheet][cell] = {"formula" => info.formula}
      end

      # Add initial value cells (that don't have formulas)
      initial_values.each do |key, _|
        parts = key.split("!", 2)
        sheet = parts.size > 1 ? parts[0] : ""
        cell = parts.size > 1 ? parts[1] : parts[0]

        sheets_data[sheet] ||= Hash(String, Hash(String, String)).new
        # Only add if there's no formula already
        unless sheets_data[sheet][cell]?
          sheets_data[sheet][cell] = {"formula" => ""}
        end
      end

      # Generate code to collect all cell data per sheet
      sheet_collection_code = sheets_data.map do |sheet, cells|
        sheet_display_name = sheet.empty? ? "(default)" : sheet
        sheet_var_name = sheet.empty? ? "default" : sheet.gsub(/[^a-zA-Z0-9]/, "_")
        sheet_key_prefix = sheet.empty? ? "" : "#{sheet}!"

        cells_array = cells.map do |cell, data|
          "{cell: #{cell.inspect}, formula: #{data["formula"].inspect}, value: Croupier::TaskManager.get(\"#{sheet_key_prefix}#{cell}\") || \"(empty)\"}"
        end.join(",\n          ")

        "  # Sheet: #{sheet_display_name}
  sheet_#{sheet_var_name}_data = [
            #{cells_array}
          ]"
      end.join("\n\n")

      sheet_print_code = sheets_data.keys.sort!.map do |sheet|
        sheet_var_name = sheet.empty? ? "default" : sheet.gsub(/[^a-zA-Z0-9]/, "_")
        sheet_display_name = sheet.empty? ? "(default)" : sheet
        "  print_sheet(sheet_#{sheet_var_name}_data, #{sheet_display_name.inspect})"
      end.join("\n")

      # Generate code to display results in a sheet layout
      %{
# Execute all tasks
puts "=== Executing Croupier Tasks ==="
Croupier::TaskManager.run_tasks

# Display results as sheets
puts ""
puts "=== Spreadsheet Results ==="
puts ""

#{sheet_collection_code}

# Helper function to convert column number to letters
def col_num_to_letter(num)
  result = ""
  while num > 0
    num -= 1
    result = ('A' + (num % 26)).to_s + result
    num //= 26
  end
  result
end

def print_sheet(data, sheet_name)
  # Find the grid dimensions
  max_col = 0
  max_row = 0

  data.each do |cell|
    if match = cell[:cell].match(/^([A-Z]+)(\\d+)$/)
      col = match[1]
      row = match[2].to_i

      # Convert column to number for comparison
      col_num = 0
      col.each_char { |c| col_num = col_num * 26 + (c.ord - 'A'.ord + 1) }

      max_col = col_num if col_num > max_col
      max_row = row if row > max_row
    end
  end

  # Create a 2D grid
  grid = Array.new(max_row) { Array.new(max_col, "") }

  # Fill the grid
  data.each do |cell|
    if match = cell[:cell].match(/^([A-Z]+)(\\d+)$/)
      col = match[1]
      row = match[2].to_i - 1  # Convert to 0-indexed

      # Convert column to number
      col_num = 0
      col.each_char { |c| col_num = col_num * 26 + (c.ord - 'A'.ord + 1) }

      value = cell[:value]
      formula = cell[:formula]

      # Display: if there's a formula, show it, otherwise just the value
      display = formula.empty? ? value : formula + " -> " + value

      grid[row][col_num - 1] = display
    end
  end

  # Build column headers (A, B, C, ...)
  column_headers = (1..max_col).map { |i| col_num_to_letter(i) }

  # Build table data with row numbers
  table_data = (0...max_row).map do |row_idx|
    [row_idx + 1] + grid[row_idx]
  end

  # Create and print the table using Tablo
  table = Tablo::Table.new(table_data) do |t|
    t.add_column("Row", &.[](0).to_s)
    (1..max_col).each do |col_idx|
      t.add_column(column_headers[col_idx - 1], &.[](col_idx).to_s)
    end
  end

  puts table
  puts ""
end

#{sheet_print_code}
puts ""
}
    end

    # Generate source code for a single task
    private def generate_single_task_source(info : FormulaInfo) : String
      formula = info.formula.starts_with?("=") ? info.formula : "=#{info.formula}"
      ast = parse_formula(formula)

      if ast.nil?
        # Invalid formula
        return %{
          Croupier::Task.new(
            id: "formula_#{sanitize_key(info.key)}",
            inputs: [] of String,
            outputs: [#{info.key.inspect}],
          ) do
            "#VALUE!"
          end
        }
      end

      # Extract dependencies - these are the inputs
      # Add kv:// prefix for k/v store keys
      dependencies = @extractor.extract(ast, info.sheet).map { |dep| "kv://#{dep}" }.to_a

      # Generate the calculation code
      calc_code = @generator.generate(ast, CodeGenerator::Context.new(info.sheet))

      # Build the task - the proc should return the result as a string
      %{
        Croupier::Task.new(
          id: "formula_#{sanitize_key(info.key)}",
          inputs: [#{dependencies.map(&.inspect).join(", ")}],
          outputs: ["kv://#{info.key}"],
        ) do
          begin
            result = (#{calc_code})

            # Convert result to string - this is what the task "outputs"
            case result
            when Float64
              if result == result.to_i
                result.to_i.to_s
              else
                result.to_s
              end
            when String
              result
            when Bool
              result.upcase.to_s
            when Sheety::Functions::ErrorValue
              result.to_s
            when Nil
              ""
            else
              result.to_s
            end
          rescue e : Exception
            "#ERROR: " + (e.message || "Unknown error")
          end
        end
      }
    end

    # Generate TUI mode
    private def generate_tui_mode(initial_values : Hash(String, Float64 | String | Bool)) : String
      # Get the sheet data collection code
      sheets_data = {} of String => Hash(String, Hash(String, String))

      @formulas.each do |key, info|
        parts = key.split("!", 2)
        sheet = parts.size > 1 ? parts[0] : ""
        cell = parts.size > 1 ? parts[1] : parts[0]

        sheets_data[sheet] ||= Hash(String, Hash(String, String)).new
        sheets_data[sheet][cell] = {"formula" => info.formula}
      end

      initial_values.each do |key, _|
        parts = key.split("!", 2)
        sheet = parts.size > 1 ? parts[0] : ""
        cell = parts.size > 1 ? parts[1] : parts[0]

        sheets_data[sheet] ||= Hash(String, Hash(String, String)).new
        unless sheets_data[sheet][cell]?
          sheets_data[sheet][cell] = {"formula" => ""}
        end
      end

      # Generate code to collect all cell data per sheet
      sheet_collection_code = sheets_data.map do |sheet, cells|
        sheet_var_name = sheet.empty? ? "default" : sheet.gsub(/[^a-zA-Z0-9]/, "_")
        sheet_key_prefix = sheet.empty? ? "" : "#{sheet}!"

        cells_array = cells.map do |cell, data|
          "{cell: #{cell.inspect}, formula: #{data["formula"].inspect}, value: Croupier::TaskManager.get(\"#{sheet_key_prefix}#{cell}\") || \"\"}"
        end.join(",\n          ")

        "  sheet_#{sheet_var_name}_data = [
            #{cells_array}
          ]"
      end.join("\n\n")

      # Build the sheets array and data hash
      sheets_array = sheets_data.keys.sort!.map do |sheet|
        sheet.inspect
      end.join(", ")

      sheets_data_init = sheets_data.keys.sort!.map do |sheet|
        sheet_var_name = sheet.empty? ? "default" : sheet.gsub(/[^a-zA-Z0-9]/, "_")
        "#{sheet.inspect} => sheet_#{sheet_var_name}_data"
      end.join(",\n    ")

      %{
# Execute all tasks
puts "=== Executing Croupier Tasks ==="
Croupier::TaskManager.run_tasks

# Collect cell data for TUI
#{sheet_collection_code}

# Build sheets array and data hash
sheets = [#{sheets_array}]
sheet_data = {
    #{sheets_data_init}
  }

# Create TUI instance
tui = Sheety::TUI.new(sheets, sheet_data) do |sheet, cell_ref, new_value|
  # Update callback: called when user saves a cell edit
  full_key = sheet.empty? ? cell_ref : sheet + "!" + cell_ref

  # Update the value in Croupier store
  Croupier::TaskManager.set(full_key, new_value)

  # Re-run dependent tasks
  Croupier::TaskManager.run_tasks
end

# Set value getter callback to fetch fresh values from Croupier store
tui.set_value_getter do |sheet, cell_ref|
  full_key = sheet.empty? ? cell_ref : sheet + "!" + cell_ref
  Croupier::TaskManager.get(full_key) || ""
end

# Set refresh callback to refresh the grid after updates
tui.set_refresh_callback do
  tui.refresh_current_sheet
end

# Run the TUI
tui.run
}
    end

    # Generate helper functions (col_num_to_letter and print_sheet)
    private def generate_helper_functions : String
      # This is the same code used in generate_execution_code
      %{
# Helper function to convert column number to letters
def col_num_to_letter(num)
  result = ""
  while num > 0
    num -= 1
    result = ('A' + (num % 26)).to_s + result
    num //= 26
  end
  result
end

def print_sheet(data, sheet_name)
  # Find the grid dimensions
  max_col = 0
  max_row = 0

  data.each do |cell|
    if match = cell[:cell].match(/^([A-Z]+)(\\d+)$/)
      col = match[1]
      row = match[2].to_i

      # Convert column to number for comparison
      col_num = 0
      col.each_char { |c| col_num = col_num * 26 + (c.ord - 'A'.ord + 1) }

      max_col = col_num if col_num > max_col
      max_row = row if row > max_row
    end
  end

  # Create a 2D grid
  grid = Array.new(max_row) { Array.new(max_col, "") }

  # Fill the grid
  data.each do |cell|
    if match = cell[:cell].match(/^([A-Z]+)(\\d+)$/)
      col = match[1]
      row = match[2].to_i - 1  # Convert to 0-indexed

      # Convert column to number
      col_num = 0
      col.each_char { |c| col_num = col_num * 26 + (c.ord - 'A'.ord + 1) }

      value = cell[:value]
      formula = cell[:formula]

      # Display: if there's a formula, show it, otherwise just the value
      display = formula.empty? ? value : formula + " -> " + value

      grid[row][col_num - 1] = display
    end
  end

  # Build column headers (A, B, C, ...)
  column_headers = (1..max_col).map { |i| col_num_to_letter(i) }

  # Build table data with row numbers
  table_data = (0...max_row).map do |row_idx|
    [row_idx + 1] + grid[row_idx]
  end

  # Create and print the table using Tablo
  table = Tablo::Table.new(table_data) do |t|
    t.add_column("Row", &.[](0).to_s)
    (1..max_col).each do |col_idx|
      t.add_column(column_headers[col_idx - 1], &.[](col_idx).to_s)
    end
  end

  puts table
  puts ""
end
}
    end
  end
end
