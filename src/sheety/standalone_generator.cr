require "yaml"
require "./parser"

module Sheety
  # Generates a standalone Crystal source file from a YAML spreadsheet definition
  class StandaloneGenerator
    def generate_source(yaml_content : String, program_name : String = "sheet") : String
      data = YAML.parse(yaml_content)

      # First pass: collect all cell values for context
      cell_values = collect_cell_values(data)

      source = [] of String

      # Include all necessary code directly
      source << "#!/usr/bin/env crystal run"
      source << "# Auto-generated by Sheety from YAML spreadsheet"
      source << "# All spreadsheet logic is embedded - no external dependencies needed"
      source << ""
      source << "# ===== EMBEDDED: Functions Module ====="
      FunctionsRegistry.get_embedded_code.split("\n").each do |line|
        source << line
      end
      source << ""
      source << "# ===== EMBEDDED: Evaluator ====="
      EvaluatorCode.get_embedded_code.split("\n").each do |line|
        source << line
      end
      source << ""
      source << "# ===== MAIN PROGRAM ====="
      source << "evaluator = SpreadsheetEvaluator.new"
      source << ""

      # Set all literal values
      data.as_h.each do |sheet_name, sheet_data|
        sheet_data.as_h.each do |cell_ref, cell_data|
          cell_data = cell_data.as_h
          if cell_data.has_key?("value")
            raw_value = cell_data["value"]
            value = parse_value(raw_value)
            cell = cell_ref.to_s
            source << "evaluator.set(\"#{cell}\", #{value}, \"#{sheet_name}\")"
          end
        end
      end

      source << ""
      source << "# Evaluate all formulas (pre-compiled to Crystal expressions)"
      source << "evaluator.calculate_all do"
      source << "  # Formula evaluations in dependency order"

      # Pre-parse all formulas and generate their Crystal expressions
      formula_expressions = Hash(String, String).new

      data.as_h.each do |sheet_name, sheet_data|
        sheet_data.as_h.each do |cell_ref, cell_data|
          cell_data = cell_data.as_h
          if cell_data.has_key?("formula")
            formula = cell_data["formula"].to_s
            cell = cell_ref.to_s
            formula_str = formula.starts_with?("=") ? formula : "=#{formula}"
            key = "#{sheet_name}!#{cell}"

            # Parse the formula and generate Crystal code
            begin
              _, builder = Parser.new.ast(formula_str)
              ast_node = builder.root

              # Generate Crystal expression for this formula
              context = CodeGenerator::Context.new(sheet_name.to_s)
              context.cells = cell_values
              expression = generate_expression(ast_node, context, sheet_name.to_s)

              formula_expressions[key] = expression
            rescue ex
              STDERR.puts "Error: Failed to parse formula #{formula} for #{key}: #{ex.message}"
              STDERR.puts ex.backtrace.join("\n")
              exit 1
            end
          end
        end
      end

      # Now generate the code with inline formula evaluation
      formula_expressions.each do |key, expression|
        source << "  # Formula for #{key}"
        source << "  begin"
        source << "    key = #{key.inspect}"
        source << "    unless evaluator.has_cell?(key)"
        source << "      value = (#{expression})"
        source << "      evaluator.set_result(key, value) unless value.is_a?(Array)"
        source << "    end"
        source << "  rescue"
        source << "    # Will retry in next iteration"
        source << "  end"
        source << ""
      end

      source << "end"

      source << ""
      source << "# Print all cells"
      source << print_results_method
      source << ""
      source << "print_results(evaluator)"

      source.join("\n")
    end

    private def collect_cell_values(data : YAML::Any) : Hash(String, Float64 | String | Bool)
      values = Hash(String, Float64 | String | Bool).new

      data.as_h.each do |sheet_name, sheet_data|
        sheet_data.as_h.each do |cell_ref, cell_data|
          cell_data = cell_data.as_h
          if cell_data.has_key?("value")
            raw_value = cell_data["value"]
            value = parse_cell_value(raw_value)
            key = "#{sheet_name}!#{cell_ref}"
            values[key] = value
          end
        end
      end

      values
    end

    private def parse_cell_value(value : YAML::Any) : Float64 | String | Bool
      raw = value.raw

      case raw
      when String
        if raw == "true"
          true
        elsif raw == "false"
          false
        else
          raw
        end
      when Int32, Int64
        raw.to_f
      when Float64
        raw
      when Bool
        raw
      else
        raw.to_s
      end
    end

    private def parse_value(value : YAML::Any) : String
      raw = value.raw

      case raw
      when String
        if raw == "true"
          "true"
        elsif raw == "false"
          "false"
        else
          raw.inspect
        end
      when Int32, Int64
        raw.to_f.to_s
      when Float64
        raw.to_s
      when Bool
        raw.to_s
      else
        raw.to_s.inspect
      end
    end

    # Generate Crystal expression from AST (similar to CodeGenerator but for standalone evaluator)
    private def generate_expression(node, context, sheet_name : String) : String
      visit_node(node, context, sheet_name)
    end

    private def visit_node(node : AST::Number, context, sheet_name)
      node.value.to_s
    end

    private def visit_node(node : AST::StringLiteral, context, sheet_name)
      node.value.inspect
    end

    private def visit_node(node : AST::Boolean, context, sheet_name)
      node.value.to_s
    end

    private def visit_node(node : AST::ErrorValue, context, sheet_name)
      "SpreadsheetError.new(#{node.error_value.inspect})"
    end

    private def visit_node(node : AST::CellRef, context, sheet_name)
      ref = node.reference
      sheet = node.sheet || context.sheet

      # Generate code to fetch from evaluator
      key = sheet ? "#{sheet}!#{ref}" : ref
      "(evaluator.get_cell(#{key.inspect}))"
    end

    private def visit_node(node : AST::RangeRef, context, sheet_name)
      range = node.range
      sheet = node.sheet || context.sheet

      # Parse and expand range
      if match = range.match(/^([A-Z]+)(\d+):([A-Z]+)(\d+)$/)
        start_col = match[1]
        start_row = match[2].to_i
        end_col = match[3]
        end_row = match[4].to_i

        # Generate array of cell fetches
        cells = expand_range(start_col, start_row, end_col, end_row, sheet)
        "[" + cells.map { |ref| "(evaluator.get_cell(#{ref.inspect}))" }.join(", ") + "]"
      else
        "[] of CellValue"
      end
    end

    private def visit_node(node : AST::NamedRef, context, sheet_name)
      "SpreadsheetError.new(\"#NAME?\")"
    end

    private def visit_node(node : AST::UnaryOp, context, sheet_name)
      operand = visit_node(node.operand, context, sheet_name)

      case node.operator
      when "+"
        "(+(#{operand}))"
      when "-"
        "(-(#{operand}))"
      when "%"
        "((#{operand}) / 100.0)"
      else
        "(#{node.operator} #{operand})"
      end
    end

    private def visit_node(node : AST::BinaryOp, context, sheet_name)
      left = visit_node(node.left, context, sheet_name)
      right = visit_node(node.right, context, sheet_name)

      case node.operator
      when "="
        "SpreadsheetFunctions.eq(#{left}, #{right})"
      when "<>"
        "SpreadsheetFunctions.ne(#{left}, #{right})"
      when "<"
        "SpreadsheetFunctions.lt(#{left}, #{right})"
      when ">"
        "SpreadsheetFunctions.gt(#{left}, #{right})"
      when "<="
        "SpreadsheetFunctions.le(#{left}, #{right})"
      when ">="
        "SpreadsheetFunctions.ge(#{left}, #{right})"
      when "&"
        "SpreadsheetFunctions.to_string(#{left}) + SpreadsheetFunctions.to_string(#{right})"
      when "+"
        "begin; ln = SpreadsheetFunctions.to_number(#{left}); rn = SpreadsheetFunctions.to_number(#{right}); (ln && rn) ? (ln + rn) : nil; end"
      when "-"
        "begin; ln = SpreadsheetFunctions.to_number(#{left}); rn = SpreadsheetFunctions.to_number(#{right}); (ln && rn) ? (ln - rn) : nil; end"
      when "*"
        "begin; ln = SpreadsheetFunctions.to_number(#{left}); rn = SpreadsheetFunctions.to_number(#{right}); (ln && rn) ? (ln * rn) : nil; end"
      when "/"
        "begin; ln = SpreadsheetFunctions.to_number(#{left}); rn = SpreadsheetFunctions.to_number(#{right}); (ln && rn) ? (ln / rn) : nil; end"
      when "^"
        "begin; ln = SpreadsheetFunctions.to_number(#{left}); rn = SpreadsheetFunctions.to_number(#{right}); (ln && rn) ? (ln ** rn) : nil; end"
      else
        "((#{left}) #{node.operator} (#{right}))"
      end
    end

    private def visit_node(node : AST::FunctionCall, context, sheet_name)
      func_name = node.function_name.upcase
      args = node.arguments.map { |arg| visit_node(arg, context, sheet_name) }

      case func_name
      when "SUM"
        "SpreadsheetFunctions.sum(#{args.join(", ")})"
      when "AVERAGE", "AVG"
        "SpreadsheetFunctions.average(#{args.join(", ")})"
      when "MIN"
        "SpreadsheetFunctions.min(#{args.join(", ")})"
      when "MAX"
        "SpreadsheetFunctions.max(#{args.join(", ")})"
      when "COUNT"
        "SpreadsheetFunctions.count(#{args.join(", ")})"
      when "ROUND"
        "SpreadsheetFunctions.round(#{args.join(", ")})"
      when "ABS"
        "SpreadsheetFunctions.abs(#{args[0]})"
      when "POWER"
        "SpreadsheetFunctions.power(#{args.join(", ")})"
      when "SQRT"
        "SpreadsheetFunctions.sqrt(#{args[0]})"
      when "MOD"
        "SpreadsheetFunctions.mod(#{args.join(", ")})"
      when "INT"
        "SpreadsheetFunctions.int(#{args[0]})"
      when "IF"
        if args.size >= 3
          "SpreadsheetFunctions.if(#{args[0]}, #{args[1]}, #{args[2]})"
        else
          "SpreadsheetError.new(\"#VALUE!\")"
        end
      when "AND"
        "SpreadsheetFunctions.and([#{args.join(", ")}])"
      when "OR"
        "SpreadsheetFunctions.or([#{args.join(", ")}])"
      when "NOT"
        "SpreadsheetFunctions.not(#{args[0]})"
      when "CONCAT", "CONCATENATE"
        "SpreadsheetFunctions.concat([#{args.join(", ")}])"
      when "LEFT"
        "SpreadsheetFunctions.left(#{args.join(", ")})"
      when "RIGHT"
        "SpreadsheetFunctions.right(#{args.join(", ")})"
      when "MID"
        if args.size >= 3
          "SpreadsheetFunctions.mid(#{args.join(", ")})"
        else
          "SpreadsheetError.new(\"#VALUE!\")"
        end
      when "LEN"
        "SpreadsheetFunctions.len(#{args[0]})"
      when "UPPER"
        "SpreadsheetFunctions.upper(#{args[0]})"
      when "LOWER"
        "SpreadsheetFunctions.lower(#{args[0]})"
      when "TRIM"
        "SpreadsheetFunctions.trim(#{args[0]})"
      else
        "SpreadsheetError.new(\"#NAME?\")"
      end
    end

    private def visit_node(node : AST::ArrayConstant, context, sheet_name)
      elements = node.elements.map { |elem| visit_node(elem, context, sheet_name) }
      "[#{elements.join(", ")}]"
    end

    private def expand_range(start_col : String, start_row : Int32, end_col : String, end_row : Int32, sheet : String?) : Array(String)
      result = [] of String
      start_col_num = column_to_number(start_col)
      end_col_num = column_to_number(end_col)

      (start_row..end_row).each do |row|
        (start_col_num..end_col_num).each do |col|
          col_str = number_to_column(col)
          ref = sheet ? "#{sheet}!#{col_str}#{row}" : "#{col_str}#{row}"
          result << ref
        end
      end

      result
    end

    private def column_to_number(col : String) : Int32
      num = 0
      col.each_char { |char| num = num * 26 + (char.ord - 'A'.ord + 1) }
      num
    end

    private def number_to_column(num : Int32) : String
      result = ""
      while num > 0
        num -= 1
        result = ('A' + (num % 26)).to_s + result
        num //= 26
      end
      result
    end

    private def print_results_method : String
      <<-CODE
        def print_results(evaluator)
          cells = evaluator.all_cells

          # Group by sheet
          sheets = Hash(String, Hash(String, Float64 | String | Bool | SpreadsheetFunctions::SpreadsheetError | Nil)).new
          cells.each do |key, value|
            if key.includes?("!")
              parts = key.split("!", 2)
              sheet = parts[0]
              cell = parts[1] || ""
            else
              sheet = "(default)"
              cell = key
            end
            sheets[sheet] ||= Hash(String, Float64 | String | Bool | SpreadsheetFunctions::SpreadsheetError | Nil).new
            sheets[sheet][cell] = value
          end

          # Print each sheet
          sheets.each do |sheet_name, sheet_cells|
            puts "--- " + sheet_name + " ---"
            sorted_cells = sheet_cells.to_a.sort do |a, b|
              ref_a = a[0]
              ref_b = b[0]
              col_a = ref_a[/[A-Z]+/]? || ""
              row_a = (ref_a[/\\d+$/]? || "0").to_i
              col_b = ref_b[/[A-Z]+/]? || ""
              row_b = (ref_b[/\\d+$/]? || "0").to_i
              col_a == col_b ? row_a <=> row_b : col_a <=> col_b
            end
            sorted_cells.each do |ref, value|
              val_str = value.is_a?(String) ? value.inspect : (value.is_a?(Float64) && value == value.to_i ? value.to_i.to_s : value.to_s)
              puts "  " + ref + ": " + val_str
            end
            puts ""
          end
        end
      CODE
    end
  end

  # Helper modules to provide embedded code
  module FunctionsRegistry
    def self.get_embedded_code : String
      <<-CODE
        module SpreadsheetFunctions
          alias CellValue = Float64 | String | Bool | SpreadsheetError | Nil

          struct SpreadsheetError
            getter error : String
            def initialize(@error : String); end
            def to_s(io : IO) : Nil; io << @error; end
            def inspect(io : IO) : Nil; io << "<Error " << @error << ">"; end
          end

          def self.div0; SpreadsheetError.new("#DIV/0!"); end
          def self.value; SpreadsheetError.new("#VALUE!"); end
          def self.ref; SpreadsheetError.new("#REF!"); end
          def self.name; SpreadsheetError.new("#NAME?"); end
          def self.num; SpreadsheetError.new("#NUM!"); end
          def self.na; SpreadsheetError.new("#N/A"); end

          private def self.extract_numbers(values : Array(CellValue)) : Array(Float64)
            values.compact_map { |v| v.is_a?(Float64) ? v : nil }
          end

          private def self.to_string(value : CellValue) : String
            case value
            when String then value
            when Float64 then value.to_s
            when Bool then value ? "TRUE" : "FALSE"
            when SpreadsheetError then value.to_s
            when Nil then ""
            else ""
            end
          end

          def self.to_float(value : CellValue) : Float64?
            case value
            when Float64 then value
            when String
              begin
                value.to_f
              rescue
                nil
              end
            when Bool then value ? 1.0 : 0.0
            else nil
            end
          end

          def self.sum(values : Array(CellValue)) : CellValue
            extract_numbers(values).sum
          end

          def self.average(values : Array(CellValue)) : CellValue
            numbers = extract_numbers(values)
            return div0 if numbers.empty?
            numbers.sum / numbers.size
          end

          def self.min(values : Array(CellValue)) : CellValue
            numbers = extract_numbers(values)
            return num if numbers.empty?
            numbers.min
          end

          def self.max(values : Array(CellValue)) : CellValue
            numbers = extract_numbers(values)
            return num if numbers.empty?
            numbers.max
          end

          def self.count(values : Array(CellValue)) : CellValue
            extract_numbers(values).size.to_f
          end

          def self.round(value : CellValue, digits : CellValue = 0.0) : CellValue
            num = to_float(value)
            d = to_float(digits) || 0.0
            return value if num.nil?
            num.round(d.to_i).to_f
          end

          def self.abs(value : CellValue) : CellValue
            num = to_float(value)
            return value if num.nil?
            num.abs
          end

          def self.power(base : CellValue, exponent : CellValue) : CellValue
            b = to_float(base)
            e = to_float(exponent)
            return value if b.nil? || e.nil?
            b ** e
          end

          def self.sqrt(value : CellValue) : CellValue
            num = to_float(value)
            return value if num.nil?
            Math.sqrt(num)
          end

          def self.mod(number : CellValue, divisor : CellValue) : CellValue
            n = to_float(number)
            d = to_float(divisor)
            return value if n.nil? || d.nil?
            return div0 if d == 0
            n % d
          end

          def self.int(value : CellValue) : CellValue
            num = to_float(value)
            return value if num.nil?
            num.floor.to_f
          end

          def self.if(condition : CellValue, true_value : CellValue, false_value : CellValue) : CellValue
            cond = condition.is_a?(Bool) ? condition : (to_float(condition) != 0.0)
            cond ? true_value : false_value
          end

          def self.and(values : Array(CellValue)) : CellValue
            return false if values.empty?
            values.all? do |v|
              v.is_a?(Bool) ? v : (v.is_a?(Float64) ? v != 0.0 : (v.is_a?(String) ? !v.empty? : false))
            end
          end

          def self.or(values : Array(CellValue)) : CellValue
            return false if values.empty?
            values.any? do |v|
              v.is_a?(Bool) ? v : (v.is_a?(Float64) ? v != 0.0 : (v.is_a?(String) ? !v.empty? : false))
            end
          end

          def self.not(value : CellValue) : CellValue
            v = value.is_a?(Bool) ? value : (value.is_a?(Float64) ? value != 0.0 : nil)
            v.nil? ? false : !v
          end

          def self.concat(values : Array(CellValue)) : CellValue
            values.map { |v| to_string(v) }.join
          end

          def self.left(text : CellValue, num_chars : CellValue = 1.0) : CellValue
            str = to_string(text)
            n = to_float(num_chars) || 1.0
            str[0...(n.to_i)]
          end

          def self.right(text : CellValue, num_chars : CellValue = 1.0) : CellValue
            str = to_string(text)
            n = to_float(num_chars) || 1.0
            return "" if n > str.size
            str[-(n.to_i)..]
          end

          def self.mid(text : CellValue, start_num : CellValue, num_chars : CellValue) : CellValue
            str = to_string(text)
            s = to_float(start_num) || 1.0
            n = to_float(num_chars) || 0.0
            return "" if s < 1
            str[(s.to_i - 1)...(s.to_i + n.to_i - 1)]
          end

          def self.len(text : CellValue) : CellValue
            to_string(text).size.to_f
          end

          def self.upper(text : CellValue) : CellValue
            to_string(text).upcase
          end

          def self.lower(text : CellValue) : CellValue
            to_string(text).downcase
          end

          def self.trim(text : CellValue) : CellValue
            to_string(text).gsub(/\\s+/, " ").strip
          end

          def self.eq(left : CellValue, right : CellValue) : CellValue
            return nil if left.is_a?(Array) || right.is_a?(Array)
            return nil if left.is_a?(SpreadsheetError) || right.is_a?(SpreadsheetError)
            case {left, right}
            when {Float64, Float64} then left == right
            when {Float64, String} then false
            when {String, Float64} then true
            when {String, String} then left == right
            when {Bool, Bool} then left == right
            else false
            end
          end

          def self.ne(left : CellValue, right : CellValue) : CellValue
            !eq(left, right)
          end

          def self.lt(left : CellValue, right : CellValue) : CellValue
            return nil if left.is_a?(Array) || right.is_a?(Array)
            return nil if left.is_a?(SpreadsheetError) || right.is_a?(SpreadsheetError)
            case {left, right}
            when {Float64, Float64} then left < right
            when {Float64, String} then true
            when {String, Float64} then false
            when {String, String} then left < right
            else false
            end
          end

          def self.gt(left : CellValue, right : CellValue) : CellValue
            return nil if left.is_a?(Array) || right.is_a?(Array)
            return nil if left.is_a?(SpreadsheetError) || right.is_a?(SpreadsheetError)
            case {left, right}
            when {Float64, Float64} then left > right
            when {Float64, String} then false
            when {String, Float64} then true
            when {String, String} then left > right
            else false
            end
          end

          def self.le(left : CellValue, right : CellValue) : CellValue
            !gt(left, right)
          end

          def self.ge(left : CellValue, right : CellValue) : CellValue
            !lt(left, right)
          end

          def self.to_number(value : CellValue) : Float64?
            case value
            when Float64 then value
            when String
              begin
                value.to_f
              rescue
                nil
              end
            when Bool then value ? 1.0 : 0.0
            when Array then nil
            else nil
            end
          end
        end
      CODE
    end
  end

  module EvaluatorCode
    def self.get_embedded_code : String
      <<-CODE
        class SpreadsheetEvaluator
          include SpreadsheetFunctions

          @cells : Hash(String, Float64 | String | Bool | SpreadsheetFunctions::SpreadsheetError | Nil)

          def initialize
            @cells = Hash(String, Float64 | String | Bool | SpreadsheetFunctions::SpreadsheetError | Nil).new
          end

          def set(cell : String, value, sheet : String? = nil)
            key = sheet ? sheet + "!" + cell : cell
            @cells[key] = value
          end

          def has_cell?(key : String) : Bool
            @cells.has_key?(key)
          end

          def set_result(key : String, value : CellValue)
            @cells[key] = value
          end

          # Helper method to get a cell value from within a formula
          def get_cell(key : String) : CellValue
            @cells[key]?
          end

          def calculate_all(&block : SpreadsheetEvaluator -> Nil)
            changed = true
            iterations = 0
            max_iterations = 100  # Safety limit

            while changed && iterations < max_iterations
              changed = false
              iterations += 1
              block.call(self)
            end
          end

          def all_cells
            @cells.dup
          end
        end
      CODE
    end
  end
end
